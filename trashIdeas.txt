            //gameSettings = GameSettings.ReadFromFile(@"./conf1.xml");
            //playerNumber = 0;
            //bank = new Bank(gameSettings.ProductionsCount);
            //for (int i = 0; i < gameSettings.ProductionsCount; i++)
            //{
            //    bank.addProduction(i);
            //    //bank.addProduction(i);
            //}
            //words = new List<List<string>>();
            //words.Add(new List<string>());
            //words.Add(new List<string>());
            //productionGroupNumber = 0;


//static KeyValuePair<int, string> findMove(SimplifiedWord oldWord, Move currentMove, Bank bank, List<SimplifiedProductionGroup> prods)
        //{
        //    KeyValuePair<int, string> bestWord
        //        = new KeyValuePair<int, string>(oldWord.terminals, currentMove.ToString()); ;
        //    KeyValuePair<int, string> tmpPair;
        //    SimplifiedWord tmpWord;
        //    SimplifiedProductionGroup prod;
        //    for (int prodIndex = 0; prodIndex < prods.Count; prodIndex++)
        //    {
        //        if (bank.getProductionCount(prodIndex) == 0) continue;

        //        prod = prods[prodIndex];
        //        if (oldWord.neterminalsCount[prod.Left] == 0) continue;

        //        bank.removeProduction(prodIndex);
        //        for (int rightIndex = 0; rightIndex < prod.RightSize; ++rightIndex)
        //        {
        //            //tmpWord = new SimplifiedWord(oldWord);
        //            oldWord.neterminalsCount[prod.Left]--;
        //            oldWord.terminals += prod.rights[rightIndex].terminals;
        //            foreach (var neterminal in prod.rights[rightIndex].neterminalsCount)
        //                oldWord.addNeterminal(neterminal.Key, neterminal.Value);


        //            currentMove.addMove(0, prodIndex, rightIndex);
        //            tmpPair = findMove(oldWord, currentMove, bank, prods);
        //            if (bestWord.Key < tmpPair.Key)
        //                bestWord = tmpPair;
        //            currentMove.popMove();
        //            oldWord.neterminalsCount[prod.Left]++;
        //            oldWord.terminals -= prod.rights[rightIndex].terminals;
        //            foreach (var neterminal in prod.rights[rightIndex].neterminalsCount)
        //                oldWord.addNeterminal(neterminal.Key, -neterminal.Value);
        //        }
        //        bank.addProduction(prodIndex);
        //    }
        //    return bestWord;
        //}


//public static void findFirstMetric(List<SimplifiedProductionGroup> productions,
        //    GameSettings settings,
        //    out int[] netMetric,
        //    out int[][] prodMetric
        //    )
        //{
        //    netMetric = new int[productions.Count];
        //    prodMetric = new int[productions.Count][];
        //    int productionsCount = productions.Count;
        //    for (int prodIndex = 0; prodIndex < productionsCount; ++prodIndex)
        //    {
        //        netMetric[prodIndex] = -1;
        //        prodMetric[prodIndex] = new int[productions[prodIndex].RightSize];
        //        for (int rightIndex = 0; rightIndex < productions[prodIndex].RightSize; ++rightIndex)
        //        {
        //            var right = productions[prodIndex].rights[rightIndex];
        //            if (right.neterminalsCount.Count == 0)
        //                netMetric[prodIndex] = prodMetric[prodIndex][rightIndex] = 1;
        //            else
        //                prodMetric[prodIndex][rightIndex] = -1;
        //        }
        //    }
        //    bool found = false;
        //    while (true)
        //    {
        //        for (int prodIndex = 0; prodIndex < productionsCount; ++prodIndex)
        //        {
        //            for (int rightIndex = 0; rightIndex < productions[prodIndex].RightSize; ++rightIndex)
        //            {
        //                var right = productions[prodIndex].rights[rightIndex];
        //                if (right.neterminalsCount.Count != 0)
        //                {//если в продукции есть нетерминалы - высчитываем её
        //                    foreach (var neterminal in right.neterminalsCount)
        //                    {
        //                        for (int i = 0; i < productionsCount; ++i)
        //                        {
        //                        }
        //                    }
        //                }
        //            }
        //        }
        //    }
        //}



//public static Dictionary<char, int> convertNeterminalsToInt(List<SimplifiedProductionGroup> productions)
        //{
        //    int neterminalCount = 0;
        //    Dictionary<char, int> charToInt = new Dictionary<char, int>();
        //    for (int i = 0; i < productions.Count; ++i)
        //    {
        //        char left = productions[i].Left;
        //        if (!charToInt.ContainsKey(left))
        //        {
        //            charToInt.Add(left, neterminalCount++);
        //        }
        //    }
        //    return charToInt;
        //}


//static bool greather(SimplifiedWord word1, SimplifiedWord word2)
        //{
        //    return word1.terminals > word2.terminals;
        //}

//static KeyValuePair<SimplifiedWord, string> findMove(SimplifiedWord oldWord, Move currentMove, Bank bank, List<SimplifiedProductionGroup> prods)
        //        {
        //            KeyValuePair<SimplifiedWord, string> bestWord
        //                = new KeyValuePair<SimplifiedWord, string>(oldWord, currentMove.ToString()); ;
        //            KeyValuePair<SimplifiedWord, string> tmpPair;
        //        SimplifiedWord tmpWord;
        //        SimplifiedProductionGroup prod;
        //            for (int prodIndex = 0; prodIndex<prods.Count; prodIndex++)
        //            {
        //                if (bank.getProductionCount(prodIndex) == 0) continue;

        //                prod = prods[prodIndex];
        //                if (oldWord.neterminalsCount[prod.Left]==0) continue;

        //                bank.removeProduction(prodIndex);
        //                for (int rightIndex = 0; rightIndex<prod.RightSize; ++rightIndex)
        //                {
        //                    tmpWord = new SimplifiedWord(oldWord);
        //        tmpWord.neterminalsCount[prod.Left]--;
        //                    tmpWord.terminals += prod.rights[rightIndex].terminals;
        //                    foreach (var neterminal in prod.rights[rightIndex].neterminalsCount)
        //                        tmpWord.addNeterminal(neterminal.Key, neterminal.Value);


        //                    currentMove.addMove(0, prodIndex, rightIndex);
        //                    tmpPair = findMove(tmpWord, currentMove, bank, prods);
        //                    if (greather(bestWord.Key, tmpPair.Key))
        //                        bestWord = tmpPair;
        //                    currentMove.popMove();
        //                }
        //    bank.addProduction(prodIndex);
        //            }
        //return bestWord;
        //        }





        static KeyValuePair<int, string> findMoveSecond(SuperSimmplifiedWord oldWord, Move currentMove, Bank bank, List<SimplifiedProductionGroup> prods)
        {
            KeyValuePair<int, string> bestWord = new KeyValuePair<int, string>(0, "");
            // = new KeyValuePair<int, string>(oldWord.terminals, currentMove.ToString()); ;
            KeyValuePair<int, string> tmpPair;
            SimplifiedWord tmpWord;
            SimplifiedProductionGroup prod;
            int prodsCount = prods.Count;
            bool found = false;
            for (int i=0;i< oldWord.neterminalCount.Length;++i)
            {
                if (neterminal.Value > 0)
                {
                    found = true;
                    for (int prodIndex = 0; prodIndex < prodsCount; prodIndex++)
                    {
                        if (prods[prodIndex].Left == neterminal.Key && bank.getProductionCount(prodIndex) > 0)
                        {
                            prod = prods[prodIndex];
                            bank.removeProduction(prodIndex);
                            for (int rightIndex = 0; rightIndex < prod.RightSize; rightIndex++)
                            {
                                oldWord.neterminalsCount[prod.Left]--;
                                oldWord.terminals += prod.rights[rightIndex].terminals;
                                foreach (var net in prod.rights[rightIndex].neterminalsCount)
                                    oldWord.addNeterminal(net.Key, net.Value);


                                currentMove.addMove(0, prodIndex, rightIndex);
                                tmpPair = findMoveSecond(oldWord, currentMove, bank, prods);
                                if (bestWord.Key < tmpPair.Key)
                                    bestWord = tmpPair;


                                currentMove.popMove();
                                oldWord.neterminalsCount[prod.Left]++;
                                oldWord.terminals -= prod.rights[rightIndex].terminals;
                                foreach (var net in prod.rights[rightIndex].neterminalsCount)
                                    oldWord.addNeterminal(net.Key, -net.Value);
                            }
                            bank.addProduction(prodIndex);
                        }
                    }
                }
            }


            if (!found)
                return new KeyValuePair<int, string>(oldWord.terminals, currentMove.ToString());
            return bestWord;
        }